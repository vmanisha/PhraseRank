 ************Class Name == phraseQuery *********************

/*
	//Load the phrase Count when its not in integer 
Vector <Double> dphraseCount = new Vector<Double> ();
	public void loadDPhraseCount(String file)
	{
		try{
			BufferedReader br = new BufferedReader (new FileReader (new File(file)));
			String line ;
			while((line = br.readLine())!=null)
				dphraseCount.add(Double.parseDouble(line));
			br.close();
		}
		catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
			closeAll();
		}

	}
*/

	/*public String extractPhrases(BufferedReader  br)
	{
		String line ;
		String Qno = null;
		String descPart;
		int window,nxt ;

		try{
			while((line=br.readLine())!=null)
			{
				if(line.startsWith("<NUM>")) //Query no
				{
					Qno=line.substring(5,line.lastIndexOf("<"));
					if(done.contains(Qno))
					{
						System.out.println("ho gai");
						Qdone=true;
						break;
					}
				}
				else if(line.startsWith("<ABST>"))
				{
					abst_phrase=util.extractNouns(line.substring(6,line.lastIndexOf("<")), tagger, jtp);
					abst_phrase=removeStopWords(abst_phrase);
				}
				else if(line.startsWith("<SPEC>"))
				{

					window = (line.lastIndexOf("<")+1)/10; //dividing the string into 3 parts
					for (int i=6;i<line.lastIndexOf("<");i++)
					{
						nxt=line.indexOf(".", i+window);
						System.out.println("desc part "+i);
						if(nxt==-1)
							nxt=line.lastIndexOf("<");
						descPart =line.substring(i,nxt);
							desc_phrase.addAll(util.extractNouns(descPart, tagger, jtp));
						i=nxt;	
					}
					desc_phrase=removeStopWords(desc_phrase);
				}
				else if(line.startsWith("<CLAIM>"))
				{
					claim_phrase=util.extractNouns(line.substring(7,line.lastIndexOf("<")), tagger, jtp);
					claim_phrase=removeStopWords(claim_phrase);
				}

			}
		}
		catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
			closeAll();
		}
		return Qno;
	}

	/*public String extractPhrases(BufferedReader br)
	{
		String qno="";


		return qno;
	}*/

/*public void getTopK (int n,HashMap hm)
{
	ArrayList fmap = new ArrayList(hm.values());
	Collections.sort(fmap);
	Collections.reverse(fmap);
	Set set;
	Iterator <Map.Entry> it;
	Map.Entry <String,Integer> me;
	Iterator i2=fmap.iterator();
	int d;
	Vector v= new Vector ();
	while(i2.hasNext())
	{
		d=(Integer)i2.next();
		if(!v.contains(d))
		{
			//System.out.println("d "+d);
			// Get an iterator
			set=hm.entrySet();
			it = set.iterator();
			// Display elements
			while(it.hasNext()) {
				me = (Map.Entry)it.next();
				//System.out.println(me.getKey()+ " "+me.getValue());
				if(me.getValue()==d)
				{
					//System.out.println("found");
				}	
			}
			v.add(d);
		}
	}


}
 */
 
	/*public String tokenizeString(String text)
	{
		text=util.processForIndex(text.toLowerCase());
		//System.out.println("Text is "+text);
		StringBuffer tokText= new StringBuffer();
		TokenStream ts;
		Token tok;
		TermAttributeImpl ati= new TermAttributeImpl();
		
		
		ts=sa.tokenStream("word", new StringReader(text));
		TermAttribute ta=ts.addAttribute(TermAttribute.class);
		ts.addAttributeImpl(ati);
		
		try{
			while(ts.incrementToken())
			tokText.append(ta.term()+" ");
			text=util.removeStopWords(tokText.toString(), stop);
		}
		catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
			System.exit(0);
		}	
		//if(text.indexOf("java")!=-1)
		//	System.out.println("tok "+text);
		
		return text.trim();
	}
	*/
 ************Class Name == phraseList *********************

/*
	void sortByType(String type)
	{
		Vector field=null;
		if(type.equals("count"))
			field=count;
		else if (type.equals("idf"))
			field=idf;
		else if (type.equals("tfIdf"))
			field=tfIDF;
		float temp;
		int temp2;
		String temp1;
		for(int i=0;i<phrase.size();i++)
			for(int j=0;j<phrase.size()-1;j++)
			{
				//System.out.println(" wcomparing "+phrase.get(j) +" "+count.get(j)+ " and "+phrase.get(j+1)+" "+count.get(j+1) );
				//System.out.println(" comparing "+count.get(j)+ " and "+count.get(j-1) );
				//System.out.println(" icomparing "+j+ " and "+(j+1) );

				if(field.get(j)<field.get(j+1))
				{
					//System.out.println(" got in "+count.get(j)+ " and "+count.get(j-1) );
					temp=idf.get(j);
					idf.set(j, idf.get(j+1));
					idf.set(j+1, temp);

					temp2=count.get(j);
					count.set(j, count.get(j+1));
					count.set(j+1, temp2);

					temp1=(String)phrase.get(j);
					phrase.set(j, phrase.get(j+1));
					phrase.set(j+1, temp1);
				}
			}

	}
 */
 
  ************Class Name == preRetrievalValues.java *********************
 
 	public int returnDocTF(String word)
	{
		int tf=0;
		
		return tf;
	}
	
	/** Calculate tf score for a word in collection
	 *	@param word for which the tf has to be calculated
	 */
	public int returnCollTF(String word)
	{
		int colltf=0;

		return colltf;
	}
	
	/** Calculate normalized collection tf score for a word  
	 *	@param phrase for which the tf has to be calculated
	 */
	public float returnNormCollTF(String phrase)
	{
		int normtf=0;
		return normtf;
	}
	
	/** Calculate normalized document tf score for a word  
	 *	@param phrase for which the tf has to be calculated
	 */
	public float returnNormDocTF(String phrase)
	{
		int normDoctf=0;
		return normDoctf;
	}
	
	/** Calculate idf score for a word  
	 *	@param word for which the idf has to be calculated
	 */
	public float returnIDF(String word) //dont know if its phrase or word
	{
		int idf=0;
		return idf;
	}
	
	/** Calculate tf-idf score for a word  
	 *	@param phrase for which the tf-idf has to be calculated
	 */
	public float returnTf_IDF(String phrase)
	{
		int tfidf=0;
		return tfidf;
	}
	
	
	/** Calculate normalized idf score for a word  
	 *	@param phrase for which the idf has to be calculated
	 */
	public float returnNormIDF(String phrase)
	{
		int normIDF=0;
		return normIDF;
	}
	
	/** Calculate Average ICTF score for a word  
	 *	@param phrase for which the ICTF has to be calculated
	 */
	public float returnAvgICTF(String phrase)
	{
		int avgICTF=0;
		return avgICTF;	
	}
	
	public float returnQueryScope(String phrase)
	{
		int scope=0;
		return scope;
	
	}
	
	public float returnSCS(String phrase)
	{
		int scs=0;
		return scs;
	}
	
	public float returnMI(String phrase)
	{
		int MI=0;
		return MI;
	}
	
 
